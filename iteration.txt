-- two different patterns for iterating over items:
--   static views:  Vec<_>
--   dynamic lists: <For/>

--  if you can render T, you can render Vec<T>
let values = vec![0, 1, 2];
view! {
    // this will just render "012"
    <p>{values.clone()}</p>
    // or we can wrap them in <li>
    <ul>
        {values.into_iter()
            .map(|n| view! { <li>{n}</li>})
            .collect::<Vec<_>>()}
    </ul>
}

-- .collect_view() allows collecting any iterator of T: IntoView into Vec<View>
let values = vec![0, 1, 2];
view! {
    // this will just render "012"
    <p>{values.clone()}</p>
    // or we can wrap them in <li>
    <ul>
        {values.into_iter()
            .map(|n| view! { <li>{n}</li>})
            .collect_view()}
    </ul>
}


-- static list doesnâ€™t mean the interface needs to be static
// create a list of 5 signals
let length = 5;
let counters = (1..=length).map(|idx| RwSignal::new(idx));

-- instead of calling signal() to get a tuple with a reader and a writer
-- here RwSignal::new() used to get a single, read-write signal
-- more convenient than passing around the tuple

// each item manages a reactive view
// but the list itself will never change
let counter_buttons = counters
    .map(|count| {
        view! {
            <li>
                <button
                    on:click=move |_| *count.write() += 1
                >
                    {count}
                </button>
            </li>
        }
    })
    .collect_view();

view! {
    <ul>{counter_buttons}</ul>
} 

-- a Fn() -> Vec<_> is rendered as an unkeyed list
-- updates for well for addition and removal at end of list

-- keyed

-- <For/> component is a keyed dynamic list. It takes three props:
--  each:       a reactive function that returns the items T to be iterated over
--  key:        a key function that takes &T and returns a stable, unique key or ID
--  children:   renders each T into a view